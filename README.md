<h3>Task 1</h3>

__Предложенный алгоритм__

Минусы:
1) При малых объемах вычисления он показывает нестабильные результаты по времени.
2) Использует больше памяти.

Плюсы:
1) Проверки типов.
2) При увеличении кол-ва элементов, теряет минимум скорости.

__Мой алгоритм__

Минусы:
1) С увеличением кол-ва элементов становиться кратно медленнее.

Плюсы:
1) При малом количестве элементов работает быстрее.
2) Использует меньше памяти.


<h3>Task 2</h3>

FirstFifo - циклический буфер FIFO на чистом python. Имеет всего два метода: append - добавление в очередь,
pop - удаление из очереди. С помощью двух указателей отслеживается актуальный индекс для добавления элемента и удаления.
Метод _\_str__ выводит полную очередь.

Добавление и удаление выполняется за O(1), так как не нужно искать/перебирать элементы, есть указатель, по которому
метод обратиться в очередь. 

В классе не реализован итератор, это можно считать минусом, но про него в ТЗ нет упоминаний.


SecondFifo - наследник от Queue. При сравнении готовых решений библиотеки queue, столкнулся с проблемами.
В классе Queue при заполнении очереди до максимума, блокируется работа всей очереди. То есть, при максимальном размере 
очереди в три элемента, мы не сможем после добавления трех элементов, добавить четвертый. Это логично, но при попытке
удалить один элемент методом get, мы не можем этого сделать.

С одной стороны это хорошо. При ручной реализации в классе FirstFifo, после заполнения очереди до максимального 
значения и при попытке добавить еще, очередь не блокируется, но данные просто теряются. После удаления методом pop, есть 
возможность продолжить работу с очередью.

При наследовании от класса SimpleQueue нет стандартного атрибута максимального размера очереди. Но у него не блокирующая
реализация. То есть можно прервать его методы этими же методами, без нарушения состояния очереди.

Сложность: добавление O(1), а вот удаление O(n), потому что после удаление происходит сдвиг всех элементов. В этом и
проблема данной реализации, по сравнению с ручным классом FirstFifo.

Для удобного использования запустите first_gui.py для FirstFifo, и second_gui.py для SecondFifo.

<h3>Task 3</h3>

**Counting sort**. Считаю сортировку подсчетом лучшей для задач, связанных с сортировкой чисел. 
Сложность O(n + k), где k = кол-во элементов между минимальным и максимальным значениями.
Сортировка в любом случае пройдет один раз по массиву, создаст еще один массив длинной k, и его заполнит. Скорость
не зависит от расположения элементов массива (будь он отсортирован или нет).

Чем меньше "перекладываний" внутри, а каждое "перекладывание" это нагрузка на процессор, тем меньше требуется времени
на вычисления. Так как по ТЗ массив из чисел, любого числа и порядка, то сортировка подсчетом подходит лучше всего.

В директории task3 есть реализация counting sort. В директории tests есть тесты для первого и третьего задания.